from regex import *;

# todo: extract common code between Java and JS processors into base class
class JavaProcessor:

    FileExtension = ".java"

    def normalize(self, s):
        # Return the class indicated in the string. Empty string returned on fail.
        # File-name example:
        # Raw file name: jEdit/src/org/gjt/sp/jedit/gui/StatusBar.java
        # Normalized file name: org/gjt/sp/jedit/gui/StatusBar

        m = REGEX_NORM_ECLIPSE.match(s)
        if m:
            return m.group(1)
        n = REGEX_NORM_JAVA_PATH.match(fixSlashes(s))
        if n:
            return n.group(1)
        return ''

    def package(self, s):
        # Return the package. Empty string returned on fail.
        # Ex: Lorg/gjt/sp/jedit/gui/statusbar/LineSepWidgetFactory$LineSepWidget -->
        #     org/gjt/sp/jedit/gui/statusbar
        m = REGEX_JAVA_PACKAGE.match(self.normalize(s))
        if m:
            return m.group(1)
        return ''

    def project(self, s):
        # Return the root folder in the given path. Empty string returned on fail.
        # In Eclipse, the root folder would be the project folder.
        # Ex: /jEdit/src/org/gjt/sp/jedit/search --> jEdit
        m = REGEX_PROJECT.match(fixSlashes(s))
        if m:
            return m.group(1)
        return ''

    #==============================================================================#
    # Helper methods for initial weights on the graph                              #
    #==============================================================================#
    # Each of these mehtods define a different level of granularity for navigations
    # PFIS3 supports betwee-method, between-class and between-package navigations.
    # These functions are passed in as parameters and rely on the list of methods
    # generated by buildPaths

    def between_method(self, a, b):
        # A navigation between methods occurs when two consecutive FQNs do not match
        return a != b

    def between_class(self, a, b):
        # A navigation between classes occurs when two consecutive normalized class
        # paths do not match
        return self.normalize(a) != self.normalize(b)

    def between_package(self, a, b):
        # A navigation between packages occurs when two conscutive pacakes do not
        # match
        return self.package(a) != self.package(b)

    def adjustInnerLocations(self, loc):
        # This split allows inner classes to be handled properly, by setting the
        # class to the outer class instead of the inner one.
        loc2 = loc.split('$')[0]
        return loc2